// Cloudflare Worker: Telegram-–±–æ—Ç "–£—á–∏—Ç–µ–ª—å"
// Secrets / Vars / KV:
// - Secret: BOT_TOKEN
// - Var: PUBLIC_URL (–±–µ–∑ –∑–∞–≤–µ—Ä—à–∞—é—â–µ–≥–æ "/")
// - KV: KV_BOT
//
// –í BotFather: /setprivacy -> Disable

const OK = (b="ok") => new Response(b,{status:200});
const NO = (c=404,b="not found") => new Response(b,{status:c});

/* ---------- Telegram API ---------- */
async function tg(method, token, payload){
  const res = await fetch(`https://api.telegram.org/bot${token}/${method}`,{
    method:"POST", headers:{ "content-type":"application/json" },
    body: JSON.stringify(payload ?? {})
  });
  return res.json();
}
async function sendSafe(method, token, payload){
  try { return await tg(method, token, payload); }
  catch(e){ console.log("SEND ERROR", method, e?.message||String(e)); return null; }
}
async function sendToSameThread(method, token, msg, payload = {}){
  const p = { ...payload, chat_id: msg.chat.id };
  if ((msg.chat?.type==="supergroup" || msg.chat?.type==="group") && msg.is_topic_message && msg.message_thread_id){
    p.message_thread_id = msg.message_thread_id;
  }
  return sendSafe(method, token, p);
}

/* ---------- KV state ---------- */
async function loadState(env){
  const raw = await env.KV_BOT.get("state");
  if(!raw) return {
    teacher_id:null,
    teacher_display_name:"–ò—Ä–∏–Ω–∞ –í–ª–∞–¥–∏–º–∏—Ä–æ–≤–Ω–∞",
    autoreply_enabled:true,
    forward_unknown_to_teacher:true,
    policy_absence:"–í—ã–∑–¥–æ—Ä–∞–≤–ª–∏–≤–∞–π—Ç–µ üôå –ü—Ä–∏–¥–∏—Ç–µ –≤ —à–∫–æ–ª—É —Å–æ —Å–ø—Ä–∞–≤–∫–æ–π –æ—Ç –≤—Ä–∞—á–∞.",
    classes:{},
    faq:[],
    teach:[]
  };
  try{
    const s = JSON.parse(raw)||{};
    s.teacher_display_name ||= "–ò—Ä–∏–Ω–∞ –í–ª–∞–¥–∏–º–∏—Ä–æ–≤–Ω–∞";
    if (typeof s.autoreply_enabled==="undefined") s.autoreply_enabled = true;
    if (typeof s.forward_unknown_to_teacher==="undefined") s.forward_unknown_to_teacher = true;
    s.policy_absence ||= "–í—ã–∑–¥–æ—Ä–∞–≤–ª–∏–≤–∞–π—Ç–µ üôå –ü—Ä–∏–¥–∏—Ç–µ –≤ —à–∫–æ–ª—É —Å–æ —Å–ø—Ä–∞–≤–∫–æ–π –æ—Ç –≤—Ä–∞—á–∞.";
    s.classes ||= {};
    s.faq ||= [];
    s.teach ||= [];
    return s;
  }catch{
    return {
      teacher_id:null,
      teacher_display_name:"–ò—Ä–∏–Ω–∞ –í–ª–∞–¥–∏–º–∏—Ä–æ–≤–Ω–∞",
      autoreply_enabled:true,
      forward_unknown_to_teacher:true,
      policy_absence:"–í—ã–∑–¥–æ—Ä–∞–≤–ª–∏–≤–∞–π—Ç–µ üôå –ü—Ä–∏–¥–∏—Ç–µ –≤ —à–∫–æ–ª—É —Å–æ —Å–ø—Ä–∞–≤–∫–æ–π –æ—Ç –≤—Ä–∞—á–∞.",
      classes:{}, faq:[], teach:[]
    };
  }
}
async function saveState(env, state){ await env.KV_BOT.put("state", JSON.stringify(state)); }

function ensureClass(state, cls){
  if(!state.classes[cls]){
    state.classes[cls] = {
      general_chat_id:null,
      parents_chat_id:null,
      // –µ–¥–∏–Ω–∏—á–Ω—ã–µ –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ:
      schedule_file_id:null, schedule_caption:null, // —É—Ä–æ–∫–∏
      bells_file_id:null, bells_caption:null, // –∑–≤–æ–Ω–∫–∏
      bus_file_id:null, bus_caption:null, // –∞–≤—Ç–æ–±—É—Å—ã
      pickup_times:null, // –≤—Ä–µ–º—è ¬´–∑–∞–±–∏—Ä–∞—Ç—å¬ª
      // –º–µ–¥–∏–∞—Ç–µ–∫–∏ –ø–æ —Ç–µ–º–∞–º:
      media:{} // { topic: [ {type, file_id, caption} ] }
    };
  }
}

/* ---------- utils ---------- */
const DAYS = ["–í–°","–ü–ù","–í–¢","–°–†","–ß–¢","–ü–¢","–°–ë"];
const DAYS_FULL = ["–í–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ","–ü–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫","–í—Ç–æ—Ä–Ω–∏–∫","–°—Ä–µ–¥–∞","–ß–µ—Ç–≤–µ—Ä–≥","–ü—è—Ç–Ω–∏—Ü–∞","–°—É–±–±–æ—Ç–∞"];
const TZ = "Europe/Kaliningrad";

function normalize(s=""){
  return s.toLowerCase()
    .replace(/—ë/g,"–µ")
    .replace(/[^a-z–∞-—è0-9\s#:+.()\-]/g," ")
    .replace(/\s+/g," ")
    .trim();
}
function parseClassFrom(text=""){
  // –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 1–ë –µ—Å–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ
  const m = text.match(/#?\s*([0-9]{1,2}\s*[–ê-–ØA-Z])/i);
  return (m ? m[1].toUpperCase().replace(/\s+/g,"") : "1–ë");
}
function extractLargestPhotoId(photos=[]){
  if(!photos?.length) return null;
  const by = [...photos].sort((a,b)=>(a.file_size||0)-(b.file_size||0));
  return by.at(-1)?.file_id || photos.at(-1)?.file_id || null;
}
function userDisplay(u){ if(!u) return ""; if(u.username) return `@${u.username}`; const n=[u.first_name,u.last_name].filter(Boolean).join(" ").trim(); return n||""; }
function addressPrefix(msg){ const d=userDisplay(msg.from||null); return d ? `${d}, ` : ""; }
function ctxKey(msg){ const chat=msg.chat.id; const th=(msg.is_topic_message && msg.message_thread_id)?msg.message_thread_id:0; return `ctx::${chat}::${th}`; }
async function rememberContext(env,msg,role,text){
  const key=ctxKey(msg); let arr=[];
  try{ arr=JSON.parse(await env.KV_BOT.get(key)||"[]")||[]; }catch{ arr=[]; }
  arr.push({t:Date.now(), role, text:(text||"").slice(0,800)});
  if(arr.length>10) arr=arr.slice(-10);
  await env.KV_BOT.put(key, JSON.stringify(arr));
}

/* ---------- class helpers ---------- */
function pickClassFromChat(state, chatId){
  for(const [k,v] of Object.entries(state.classes||{})){
    if (v.general_chat_id===chatId || v.parents_chat_id===chatId) return k;
  }
  return null;
}
const orderDays=["–ü–ù","–í–¢","–°–†","–ß–¢","–ü–¢","–°–ë","–í–°"];
function formatPickupWeek(m){ return orderDays.map(d=>`${d} ‚Äî ${m?.[d]||"‚Äî"}`).join("\n"); }
function ruShortFromDate(d){ const idx = Number(new Date(d.toLocaleString("en-US",{timeZone:TZ})).getDay()); return DAYS[idx]; }
function todayRuShort(){ return ruShortFromDate(new Date()); }
function dayNameFull(short){ const i=DAYS.indexOf(short); return i>=0?DAYS_FULL[i]:short; }
function dayShortFromInput(s=""){
  const n=normalize(s);
  if(n==="—Å–µ–≥–æ–¥–Ω—è") return todayRuShort();
  if(n==="–∑–∞–≤—Ç—Ä–∞"){ const d=new Date(); d.setUTCMinutes(d.getUTCMinutes()+24*60); return ruShortFromDate(d); }
  const map={ "–ø–Ω":"–ü–ù","–ø–æ–Ω":"–ü–ù","–ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫":"–ü–ù","–≤—Ç":"–í–¢","–≤—Ç–æ—Ä–Ω–∏–∫":"–í–¢","—Å—Ä":"–°–†","—Å—Ä–µ–¥–∞":"–°–†","—á—Ç":"–ß–¢","—á–µ—Ç–≤–µ—Ä–≥":"–ß–¢","–ø—Ç":"–ü–¢","–ø—è—Ç–Ω–∏—Ü–∞":"–ü–¢","—Å–±":"–°–ë","—Å—É–±–±–æ—Ç–∞":"–°–ë","–≤—Å":"–í–°","–≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ":"–í–°" };
  return map[n]||null;
}

/* ---------- TEACH (–ø—Ä–æ—Å—Ç–æ–π) ---------- */
function findTeachAnswer(state, question){
  const qn = normalize(question);
  for(const r of state.teach||[]){
    const pn = normalize(r.pat);
    if (pn && qn.includes(pn)) return r.ans;
  }
  return null;
}

/* ---------- NATURAL intents ---------- */
function extractTimeHHMM(text){ const m=text.match(/(\b[01]?\d|2[0-3]):([0-5]\d)\b/); return m?`${m[1].padStart(2,"0")}:${m[2]}`:null; }
function extractTimeFlexible(text){ const m=text.match(/\b([01]?\d|2[0-3])[.: \-]?([0-5]\d)\b/); return m?`${m[1].padStart(2,"0")}:${m[2]}`:null; }
function extractDelayMinutes(text){ const m=normalize(text).match(/\b–Ω–∞\s+(\d{1,2})\s*–º–∏–Ω/); return m?parseInt(m[1],10):null; }

/* ---------- MEDIALIB (—Ç–µ–º—ã) ---------- */
function pushMedia(state, cls, topic, item){
  ensureClass(state, cls);
  const lib = state.classes[cls].media ||= {};
  const arr = lib[topic] ||= [];
  // –∞–Ω—Ç–∏–¥—É–±–ª—å –ø–æ file_id
  if (!arr.some(x=>x.file_id===item.file_id)) arr.push(item);
}
function listMedia(state, cls){
  ensureClass(state, cls);
  const lib = state.classes[cls].media||{};
  return Object.fromEntries(Object.entries(lib).map(([k,v])=>[k, v.length]));
}
function delMedia(state, cls, topic, idx){
  ensureClass(state, cls);
  const lib = state.classes[cls].media||{};
  if(!lib[topic]) return false;
  if(idx==="all"){ delete lib[topic]; return true; }
  const i = Number(idx)-1;
  if(isNaN(i)||i<0||i>=lib[topic].length) return false;
  lib[topic].splice(i,1);
  if(!lib[topic].length) delete lib[topic];
  return true;
}
function clearMedia(state, cls){
  ensureClass(state, cls);
  state.classes[cls].media = {};
}

/* ---------- send media helpers ---------- */
async function sendMediaItems(token, msg, items){
  // Telegram –∞–ª—å–±–æ–º –¥–æ–ø—É—Å–∫–∞–µ—Ç —Ç–æ–ª—å–∫–æ —Ñ–æ—Ç–æ/–≤–∏–¥–µ–æ ‚Äî —à–ª—ë–º –ø–æ –æ–¥–Ω–æ–º—É
  for(const it of items){
    if (it.type==="photo"){
      await sendToSameThread("sendPhoto", token, msg, { photo: it.file_id, caption: it.caption?.slice(0,1024) });
    } else if (it.type==="video"){
      await sendToSameThread("sendVideo", token, msg, { video: it.file_id, caption: it.caption?.slice(0,1024) });
    } else if (it.type==="document"){
      await sendToSameThread("sendDocument", token, msg, { document: it.file_id, caption: it.caption?.slice(0,1024) });
    } else if (it.type==="audio"){
      await sendToSameThread("sendAudio", token, msg, { audio: it.file_id, caption: it.caption?.slice(0,1024) });
    } else if (it.type==="voice"){
      await sendToSameThread("sendVoice", token, msg, { voice: it.file_id, caption: it.caption?.slice(0,1024) });
    }
  }
}

/* ---------- commands ---------- */
async function cmdStart(token, chatId){
  const text = [
    "–ö–æ–º–∞–Ω–¥—ã:",
    "/iam_teacher ‚Äî –Ω–∞–∑–Ω–∞—á–∏—Ç—å —Å–µ–±—è —É—á–∏—Ç–µ–ª–µ–º (–õ–°)",
    "/link_general <–ö–õ–ê–°–°> ‚Äî –ø—Ä–∏–≤—è–∑–∞—Ç—å —ç—Ç–æ—Ç —á–∞—Ç –∫–∞–∫ –æ–±—â–∏–π",
    "/link_parents <–ö–õ–ê–°–°> ‚Äî –ø—Ä–∏–≤—è–∑–∞—Ç—å —ç—Ç–æ—Ç —á–∞—Ç –∫–∞–∫ —á–∞—Ç —Ä–æ–¥–∏—Ç–µ–ª–µ–π",
    "/pickup_set <–ö–õ–ê–°–°> –ü–ù=13:30,–í–¢=12:40,...",
    "/pickup_week [–ö–õ–ê–°–°] ‚Äî –≤—Ä–µ–º—è –∑–∞–±–æ—Ä–∞ –Ω–∞ –Ω–µ–¥–µ–ª—é",
    "/teach \"—à–∞–±–ª–æ–Ω\" => \"–æ—Ç–≤–µ—Ç\"",
    "/teach_list, /teach_del <‚Ññ>, /teach_clear",
    "/persona_set –ò–º—è –§–∞–º–∏–ª–∏—è ‚Äî –ø–æ–¥–ø–∏—Å—å (–º–æ–∂–Ω–æ –≤—ã–∫–ª—é—á–∏—Ç—å –ø—Ä–µ—Ñ–∏–∫—Å)",
    "/forward_unknown on|off ‚Äî –ø–µ—Ä–µ—Å—ã–ª–∫–∞ –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã—Ö –≤–æ–ø—Ä–æ—Å–æ–≤ —É—á–∏—Ç–µ–ª—é",
    "",
    "–ú–µ–¥–∏–∞-–∫–æ–ª–ª–µ–∫—Ü–∏–∏ (–∫–∞—Ä—Ç–∞/–±–∞–ª–∞–Ω—Å):",
    "/media_list [–ö–õ–ê–°–°], /media_del <—Ç–µ–º–∞> <‚Ññ|all> [–ö–õ–ê–°–°], /media_clear [–ö–õ–ê–°–°]",
    "",
    "–ó–∞–≥—Ä—É–∑–∫–∞ –æ—Ç —É—á–∏—Ç–µ–ª—è –≤ –õ–°:",
    "‚àô –§–æ—Ç–æ —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è/–∑–≤–æ–Ω–∫–æ–≤/–∞–≤—Ç–æ–±—É—Å–æ–≤ ‚Äî –±–æ—Ç –ø—É–±–ª–∏–∫—É–µ—Ç –∞–∫—Ç—É–∞–ª—å–Ω–æ–µ –≤ —á–∞—Ç—ã.",
    "‚àô ¬´–ö–∞—Ä—Ç–∞/–ë–∞–ª–∞–Ω—Å¬ª ‚Äî –±–æ—Ç —Ç–æ–ª—å–∫–æ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç —Ñ–∞–π–ª—ã –ø–æ —Ç–µ–º–µ (–±–µ–∑ –∞–≤—Ç–æ–ø—É–±–ª–∏–∫–∞—Ü–∏–∏)."
  ].join("\n");
  await sendSafe("sendMessage", token, { chat_id: chatId, text });
}
async function cmdPing(token, msg){ await sendToSameThread("sendMessage", token, msg, { text:"pong ‚úÖ" }); }
async function cmdIamTeacher(env, token, msg, state){
  if (msg.chat.type!=="private") return sendToSameThread("sendMessage", token, msg, { text:"–ö–æ–º–∞–Ω–¥–∞ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –≤ –ª–∏—á–∫–µ." });
  state.teacher_id = msg.from.id; await saveState(env, state);
  await sendSafe("sendMessage", token, { chat_id: msg.chat.id, text:"–í—ã –Ω–∞–∑–Ω–∞—á–µ–Ω—ã —É—á–∏—Ç–µ–ª–µ–º ‚úÖ" });
}
async function cmdLink(token, msg, state, args, kind){
  const cls = parseClassFrom(args||"");
  ensureClass(state, cls);
  state.classes[cls][ kind==="link_general" ? "general_chat_id" : "parents_chat_id" ] = msg.chat.id;
  await sendToSameThread("sendMessage", token, msg, { text:`–ü—Ä–∏–≤—è–∑–∞–Ω–æ: ${kind==="link_general"?"–û–ë–©–ò–ô":"–†–û–î–ò–¢–ï–õ–ò"} —á–∞—Ç –¥–ª—è ${cls} ‚úÖ` });
}

/* ---------- —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è / –∞–≤—Ç–æ–±—É—Å—ã ---------- */
async function publishSingleFileToClassChats(token, state, cls, file_id, caption){
  const rec = state.classes[cls];
  const targets = [rec.general_chat_id, rec.parents_chat_id].filter(Boolean);
  for (const chatId of targets) await sendSafe("sendPhoto", token, { chat_id: chatId, photo: file_id, caption });
}
async function handleScheduleBusesUpload(env, token, msg, state, cls, caption, file_id){
  const n = normalize(caption);
  if (/–∑–≤–æ–Ω–∫/.test(n)){ // –∑–≤–æ–Ω–∫–∏
    state.classes[cls].bells_file_id = file_id;
    state.classes[cls].bells_caption = caption;
    await saveState(env, state);
    await publishSingleFileToClassChats(token, state, cls, file_id, caption);
    await sendSafe("sendMessage", token, { chat_id: msg.chat.id, text:`–ó–≤–æ–Ω–∫–∏ –¥–ª—è ${cls} –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω—ã ‚úÖ` });
    return true;
  }
  if (/(–∞–≤—Ç–æ–±—É—Å|–ø–æ–¥–≤–æ–∑|bus)/.test(n)){ // –∞–≤—Ç–æ–±—É—Å—ã
    state.classes[cls].bus_file_id = file_id;
    state.classes[cls].bus_caption = caption;
    await saveState(env, state);
    await publishSingleFileToClassChats(token, state, cls, file_id, caption);
    await sendSafe("sendMessage", token, { chat_id: msg.chat.id, text:`–ê–≤—Ç–æ–±—É—Å—ã –¥–ª—è ${cls} –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω—ã ‚úÖ` });
    return true;
  }
  // –∏–Ω–∞—á–µ ‚Äî —Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ —É—Ä–æ–∫–æ–≤
  state.classes[cls].schedule_file_id = file_id;
  state.classes[cls].schedule_caption = caption;
  await saveState(env, state);
  await publishSingleFileToClassChats(token, state, cls, file_id, caption);
  await sendSafe("sendMessage", token, { chat_id: msg.chat.id, text:`–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è ${cls} –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω–æ ‚úÖ` });
  return true;
}

/* ---------- –∑–∞–≥—Ä—É–∑–∫–∞ –º–µ–¥–∏–∞ –æ—Ç —É—á–∏—Ç–µ–ª—è (–õ–°) ---------- */
async function handleMediaFromTeacher(env, token, msg, state){
  if (msg.chat.type!=="private") return;
  if (!state.teacher_id || state.teacher_id!==msg.from.id){
    await sendSafe("sendMessage", token, { chat_id: msg.chat.id, text:"–¢–æ–ª—å–∫–æ —É—á–∏—Ç–µ–ª—å –º–æ–∂–µ—Ç –∑–∞–≥—Ä—É–∂–∞—Ç—å (–≤–≤–µ–¥–∏—Ç–µ /iam_teacher –≤ –ª–∏—á–∫–µ)." });
    return;
  }
  const caption = msg.caption || "";
  const cls = parseClassFrom(caption||""); // 1–ë –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
  ensureClass(state, cls);

  // —Ä–∞—Å–ø–æ–∑–Ω–∞—ë–º file_id + —Ç–∏–ø
  let file_id=null, type=null;
  if (msg.photo?.length){ file_id = extractLargestPhotoId(msg.photo); type="photo"; }
  else if (msg.video){ file_id = msg.video.file_id; type="video"; }
  else if (msg.document){ file_id = msg.document.file_id; type="document"; }
  else if (msg.audio){ file_id = msg.audio.file_id; type="audio"; }
  else if (msg.voice){ file_id = msg.voice.file_id; type="voice"; }
  if (!file_id){ await sendSafe("sendMessage", token, { chat_id: msg.chat.id, text:"–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –≤–ª–æ–∂–µ–Ω–∏–µ." }); return; }

  const n = normalize(caption);

  // –¢–µ–º—ã, –∫–æ—Ç–æ—Ä—ã–µ –∫–æ–ø–∏–º (–±–µ–∑ –∞–≤—Ç–æ–ø—É–±–ª–∏–∫–∞—Ü–∏–∏)
  if (/\b(–ø–æ–ø–æ–ª|–ø–æ–ø–æ–ª–Ω|–ø–ª–∞—Ç–µ–∂.*–∫–∞—Ä—Ç|–∫–∞—Ä—Ç–∞.*–ø–æ–ø–æ–ª)/.test(n)){
    pushMedia(state, cls, "topup", { type, file_id, caption });
    await saveState(env, state);
    await sendSafe("sendMessage", token, { chat_id: msg.chat.id, text:`–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ (${cls} ‚Äî topup).` });
    return;
  }
  if (/\b(–±–∞–ª–∞–Ω—Å|–ø—Ä–æ–≤–µ—Ä–∏—Ç—å.*–±–∞–ª–∞–Ω—Å|–æ—Å—Ç–∞—Ç–æ–∫.*–∫–∞—Ä—Ç)/.test(n)){
    pushMedia(state, cls, "balance", { type, file_id, caption });
    await saveState(env, state);
    await sendSafe("sendMessage", token, { chat_id: msg.chat.id, text:`–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ (${cls} ‚Äî balance).` });
    return;
  }

  // –ò–Ω–∞—á–µ ‚Äî —Ä–∞—Å–ø–∏—Å–∞–Ω–∏—è/–∑–≤–æ–Ω–∫–∏/–∞–≤—Ç–æ–±—É—Å—ã (–∞–≤—Ç–æ–ø—É–±–ª–∏–∫–∞—Ü–∏—è)
  await handleScheduleBusesUpload(env, token, msg, state, cls, caption, file_id);
}

/* ---------- natural replies & triggers ---------- */
function resolvePickupNatural(state, msg, freeText, teacherName){
  let cls = pickClassFromChat(state, msg.chat.id) || parseClassFrom(freeText||"");
  ensureClass(state, cls);
  const rec = state.classes[cls];
  if (!rec.pickup_times) return { ok:false, text:`–î–ª—è ${cls} –µ—â–µ –Ω–µ –∑–∞–¥–∞–Ω–æ –≤—Ä–µ–º—è –∑–∞–±–æ—Ä–∞. –£—á–∏—Ç–µ–ª—å: /pickup_set ${cls} –ü–ù=13:30,–í–¢=12:40,...` };
  let d = dayShortFromInput(freeText||"");
  if (!d){
    if (/–∑–∞–≤—Ç—Ä–∞/.test(normalize(freeText||""))){ const now=new Date(); now.setUTCMinutes(now.getUTCMinutes()+24*60); d=ruShortFromDate(now); }
    else d=todayRuShort();
  }
  const t = rec.pickup_times[d];
  if (!t) return { ok:false, text:`${cls}: –Ω–∞ ${dayNameFull(d)} –≤—Ä–µ–º—è –Ω–µ –∑–∞–¥–∞–Ω–æ.` };
  const pref = addressPrefix(msg);
  return { ok:true, text:`${pref}${teacherName}: ${cls}, ${dayNameFull(d)} ‚Äî –∑–∞–±–∏—Ä–∞–µ–º –≤ ${t}.` };
}

async function handleNaturalMessage(env, token, msg, state){
  if (state.autoreply_enabled===false) return false;
  const raw = (msg.text||"").trim();
  if (!raw) return false;
  const t = normalize(raw);
  const pref = addressPrefix(msg);

  await rememberContext(env, msg, "user", raw);

  // teach-–ø—Ä–∞–≤–∏–ª–∞
  const taught = findTeachAnswer(state, raw);
  if (taught){
    const txt = `${pref}${state.teacher_display_name}: ${taught}`;
    await sendToSameThread("sendMessage", token, msg, { text: txt });
    await rememberContext(env, msg, "bot", txt);
    return true;
  }

  // –ø—Ä–∏–≤–µ—Ç/—Å–ø–∞—Å–∏–±–æ
  if (/(^| )(–ø—Ä–∏–≤–µ—Ç|–∑–¥—Ä–∞–≤—Å—Ç–≤—É–π|–∑–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ|–¥–æ–±—Ä—ã–π –¥–µ–Ω—å|–¥–æ–±—Ä–æ–µ —É—Ç—Ä–æ|–¥–æ–±—Ä—ã–π –≤–µ—á–µ—Ä)( |!|$)/.test(t)){
    const txt = `${pref}${state.teacher_display_name}: –∑–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ!`;
    await sendToSameThread("sendMessage", token, msg, { text: txt });
    await rememberContext(env, msg, "bot", txt);
    return true;
  }
  if (/(^| )(—Å–ø–∞—Å–∏–±–æ|–±–ª–∞–≥–æ–¥–∞—Ä—é)( |!|$)/.test(t)){
    const txt = `${pref}${state.teacher_display_name}: –ø–æ–∂–∞–ª—É–π—Å—Ç–∞!`;
    await sendToSameThread("sendMessage", token, msg, { text: txt });
    await rememberContext(env, msg, "bot", txt);
    return true;
  }

  // –ë–æ–ª–µ–∑–Ω—å/–æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ ‚Äî –±–µ–∑ –∏–º–µ–Ω–∏ —Ä–µ–±—ë–Ω–∫–∞
  if (/(–∑–∞–±–æ–ª–µ–ª|–∑–∞–±–æ–ª–µ–ª–∞|–±–æ–ª–µ–µ—Ç|—Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä|–æ—Ä–≤–∏|–≥—Ä–∏–ø–ø|–Ω–∞—Å–º–æ—Ä–∫|—Å–æ–ø–ª|–∫–∞—à–ª—è)/.test(t)){
    const txt = `${pref}${state.teacher_display_name}: –í—ã–∑–¥–æ—Ä–∞–≤–ª–∏–≤–∞–π—Ç–µ üôå –ü—Ä–∏–¥–∏—Ç–µ –≤ —à–∫–æ–ª—É —Å–æ —Å–ø—Ä–∞–≤–∫–æ–π –æ—Ç –≤—Ä–∞—á–∞.`;
    await sendToSameThread("sendMessage", token, msg, { text: txt });
    await rememberContext(env, msg, "bot", txt);
    if (state.teacher_id) await sendSafe("sendMessage", token, { chat_id: state.teacher_id, text:`[–ë–æ–ª–µ–∑–Ω—å] ${msg.chat.title||msg.chat.id}:\n${raw}` });
    return true;
  }

  // ¬´–Ω–µ –±—É–¥–µ—Ç / –ø—Ä–æ–ø—É—Å—Ç–∏—Ç¬ª –±–µ–∑ –º–µ–¥. —Å–ª–æ–≤
  if (/(–Ω–µ\s+–±—É–¥–µ—Ç|–ø—Ä–æ–ø—É—Å—Ç–∏—Ç|–Ω–µ\s+–ø—Ä–∏–¥[–µ—ë]—Ç|–æ—Ç—Å—É—Ç—Å—Ç–≤—É)/.test(t) && !/(–∑–∞–±–æ–ª|—Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä|–æ—Ä–≤–∏|–≥—Ä–∏–ø–ø|–Ω–∞—Å–º–æ—Ä–∫|—Å–æ–ø–ª|–∫–∞—à–ª—è)/.test(t)){
    const txt = `${pref}${state.teacher_display_name}: –ü—Ä–∏–Ω—è–ª–∞. –°–æ–æ–±—â–∏—Ç–µ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–∏—á–∏–Ω—É –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è –≤ –ª–∏—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è.`;
    await sendToSameThread("sendMessage", token, msg, { text: txt });
    await rememberContext(env, msg, "bot", txt);
    if (state.teacher_id) await sendSafe("sendMessage", token, { chat_id: state.teacher_id, text:`[–û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ] ${msg.chat.title||msg.chat.id}:\n${raw}` });
    return true;
  }

  // –û–ø–æ–∑–¥–∞–µ–º/–±–µ–∂–∏–º/–∑–∞–¥–µ—Ä–∂–∏–º—Å—è
  if (/(–æ–ø–∞–∑–¥—ã–≤–∞|–æ–ø–æ–∑–¥–∞|–∑–∞–¥–µ—Ä–∂–∏–≤–∞|–±—É–¥–µ–º –ø–æ–∑–∂–µ|–±–µ–∂–∏–º)/.test(t)){
    const tm = extractTimeHHMM(raw) || extractTimeFlexible(raw);
    const delay = extractDelayMinutes(raw);
    const when = tm ? `–∫ ${tm}` : (delay ? `–Ω–∞ ~${delay} –º–∏–Ω` : "–Ω–µ–º–Ω–æ–≥–æ");
    const txt = `${pref}${state.teacher_display_name}: –ü–æ–Ω—è–ª–∞, –∂–¥—ë–º ${when}.`;
    await sendToSameThread("sendMessage", token, msg, { text: txt });
    await rememberContext(env, msg, "bot", txt);
    if (state.teacher_id) await sendSafe("sendMessage", token, { chat_id: state.teacher_id, text:`[–û–ø–æ–∑–¥–∞–Ω–∏–µ] ${msg.chat.title||msg.chat.id}:\n${raw}` });
    return true;
  }

  // –û—Ç–ø—É—Å—Ç–∏—Ç—å –ø–æ—Ä–∞–Ω—å—à–µ
  if (/(–æ—Ç–ø—É—Å—Ç(–∏|–∏—Ç–µ)|—É–π–¥[–µ—ë]–º.*—Ä–∞–Ω—å—à–µ|—É–π–¥—É.*—Ä–∞–Ω—å—à–µ|–∑–∞–±–µ—Ä—É\s*–≤|–∑–∞–±–∏—Ä–∞—Ç—å\s*–≤|–∑–∞–±–µ—Ä[—É—ë])/.test(t)){
    const tm = extractTimeHHMM(raw) || extractTimeFlexible(raw);
    const when = tm ? `–≤ ${tm}` : "—Ä–∞–Ω—å—à–µ –æ–±—ã—á–Ω–æ–≥–æ";
    const txt = `${pref}${state.teacher_display_name}: –•–æ—Ä–æ—à–æ, –æ—Ç–ø—É—Å—Ç–∏–º ${when}.`;
    await sendToSameThread("sendMessage", token, msg, { text: txt });
    await rememberContext(env, msg, "bot", txt);
    if (state.teacher_id) await sendSafe("sendMessage", token, { chat_id: state.teacher_id, text:`[–û—Ç–ø—É—Å—Ç–∏—Ç—å] ${msg.chat.title||msg.chat.id}:\n${raw}` });
    return true;
  }

  // –í–æ —Å–∫–æ–ª—å–∫–æ –∑–∞–∫–∞–Ω—á–∏–≤–∞—é—Ç—Å—è —É—Ä–æ–∫–∏
  if (/(–≤–æ —Å–∫–æ–ª—å–∫–æ|–¥–æ —Å–∫–æ–ª—å–∫–∏|–∫–æ–≥–¥–∞).*(–∑–∞–∫–∞–Ω—á|–∫–æ–Ω—á–∞—Ç|–æ–∫–æ–Ω—á–∞–Ω).*(—É—Ä–æ–∫)/.test(t)){
    const r = resolvePickupNatural(state, msg, raw, state.teacher_display_name);
    if (r.ok){
      await sendToSameThread("sendMessage", token, msg, { text:r.text });
      await rememberContext(env, msg, "bot", r.text);
    }
    return true; // –ø–æ —É—Å–ª–æ–≤–∏—é –º–æ–ª—á–∏–º, –µ—Å–ª–∏ –Ω–µ –∑–Ω–∞–µ–º
  }

  // ¬´–≤–æ —Å–∫–æ–ª—å–∫–æ –∑–∞–±–∏—Ä–∞—Ç—å¬ª
  if (/(–≤–æ —Å–∫–æ–ª—å–∫–æ|–∫–æ–≥–¥–∞).*(–∑–∞–±–∏—Ä|–∑–∞–±—Ä–∞—Ç—å|–∑–∞–±–∏—Ä–∞—Ç—å)/.test(t)){
    const r = resolvePickupNatural(state, msg, raw, state.teacher_display_name);
    await sendToSameThread("sendMessage", token, msg, { text:r.text });
    await rememberContext(env, msg, "bot", r.text);
    return true;
  }

  // –ö–∞—Ä—Ç–∞ ‚Äî –∫–æ–º–ø–ª–µ–∫—Ç
  if (/(–∫–∞–∫.*–ø–æ–ø–æ–ª|–ø–æ–ø–æ–ª–Ω–∏—Ç—å.*–∫–∞—Ä—Ç|–ø–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –∫–∞—Ä—Ç—ã)/.test(t)){
    const cls = pickClassFromChat(state, msg.chat.id) || "1–ë";
    const items = (state.classes[cls]?.media?.topup || []).slice(0,20);
    if (items.length){ await sendMediaItems(token, msg, items); }
    return true;
  }
  // –ë–∞–ª–∞–Ω—Å ‚Äî –∫–æ–º–ø–ª–µ–∫—Ç
  if (/(–±–∞–ª–∞–Ω—Å.*–∫–∞—Ä—Ç|–∫–∞–∫ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –±–∞–ª–∞–Ω—Å)/.test(t)){
    const cls = pickClassFromChat(state, msg.chat.id) || "1–ë";
    const items = (state.classes[cls]?.media?.balance || []).slice(0,20);
    if (items.length){ await sendMediaItems(token, msg, items); }
    return true;
  }

  // –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ —É—Ä–æ–∫–æ–≤ ‚Äî –ø–æ —Ñ—Ä–∞–∑–∞–º "–∫–∞–∫–∏–µ —É—Ä–æ–∫–∏ —Å–µ–≥–æ–¥–Ω—è/–∑–∞–≤—Ç—Ä–∞/–≤ —Å—Ä–µ–¥—É"
  const dayInText = /(—Å–µ–≥–æ–¥–Ω—è|–∑–∞–≤—Ç—Ä–∞|–ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫|–≤—Ç–æ—Ä–Ω–∏–∫|—Å—Ä–µ–¥–∞|—á–µ—Ç–≤–µ—Ä–≥|–ø—è—Ç–Ω–∏—Ü–∞|—Å—É–±–±–æ—Ç–∞|–≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ)/.test(t);
  if (/(–∫–∞–∫–∏–µ|—á—Ç–æ –∑–∞).*(—É—Ä–æ–∫|–ø—Ä–µ–¥–º–µ—Ç)/.test(t) && (dayInText || /—Ä–∞—Å–ø–∏—Å–∞–Ω/.test(t))){
    const cls = pickClassFromChat(state, msg.chat.id) || "1–ë";
    const rec = state.classes[cls]||{};
    if (rec.schedule_file_id){
      await sendToSameThread("sendPhoto", token, msg, { photo: rec.schedule_file_id, caption: rec.schedule_caption||`–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ ${cls}` });
    }
    return true;
  }
  // –õ—é–±–æ–µ ¬´—Ä–∞—Å–ø–∏—Å–∞–Ω–∏–µ ...¬ª –±–µ–∑ —Å–ª–æ–≤ –ø—Ä–æ –∞–≤—Ç–æ–±—É—Å/–∑–≤–æ–Ω–∫–∏ ‚Äî —Ç–æ–∂–µ —à–ª—ë–º —É—Ä–æ–∫–∏
  if (/—Ä–∞—Å–ø–∏—Å–∞–Ω–∏[–µ—è](?!.*(–∞–≤—Ç–æ–±—É—Å|–ø–æ–¥–≤–æ–∑|–∑–≤–æ–Ω–∫))/i.test(msg.text||"")){
    const cls = pickClassFromChat(state, msg.chat.id) || "1–ë";
    const rec = state.classes[cls]||{};
    if (rec.schedule_file_id){
      await sendToSameThread("sendPhoto", token, msg, { photo: rec.schedule_file_id, caption: rec.schedule_caption||`–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ ${cls}` });
    }
    return true;
  }

  // –ê–≤—Ç–æ–±—É—Å—ã / –ø–æ–¥–≤–æ–∑
  if (/(—Ä–∞—Å–ø–∏—Å–∞–Ω–∏.*–∞–≤—Ç–æ–±—É—Å|–ø–æ–¥–≤–æ–∑)/.test(t)){
    const cls = pickClassFromChat(state, msg.chat.id) || "1–ë";
    const rec = state.classes[cls]||{};
    if (rec.bus_file_id){
      await sendToSameThread("sendPhoto", token, msg, { photo: rec.bus_file_id, caption: rec.bus_caption||`–ê–≤—Ç–æ–±—É—Å—ã ${cls}` });
    }
    return true;
  }

  // –ó–≤–æ–Ω–∫–∏
  if (/(—Ä–∞—Å–ø–∏—Å–∞–Ω–∏.*–∑–≤–æ–Ω–∫|–∫–æ–≥–¥–∞ –ø–µ—Ä–µ–º–µ–Ω–∞|–≤–æ —Å–∫–æ–ª—å–∫–æ –∑–≤–æ–Ω–æ–∫)/.test(t)){
    const cls = pickClassFromChat(state, msg.chat.id) || "1–ë";
    const rec = state.classes[cls]||{};
    if (rec.bells_file_id){
      await sendToSameThread("sendPhoto", token, msg, { photo: rec.bells_file_id, caption: rec.bells_caption||`–ó–≤–æ–Ω–∫–∏ ${cls}` });
    }
    return true;
  }

  // –ù–µ –∑–Ω–∞–µ–º ‚Äî –º–æ–ª—á–∏–º; –ø—Ä–∏ –≤–∫–ª—é—á—ë–Ω–Ω–æ–π –ø–µ—Ä–µ—Å—ã–ª–∫–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —É—á–∏—Ç–µ–ª—é
  if (state.forward_unknown_to_teacher && state.teacher_id){
    await sendSafe("sendMessage", token, { chat_id: state.teacher_id, text:`[–í–æ–ø—Ä–æ—Å] ${msg.chat.title||msg.chat.id}:\n${raw}` });
  }
  return true;
}

/* ---------- commands router ---------- */
async function handleCommand(env, token, msg, state){
  const text=(msg.text||"").trim();
  const [cmd, ...rest] = text.split(/\s+/);
  const args = rest.join(" ").trim();

  switch(cmd){
    case "/start": await cmdStart(token, msg.chat.id); return true;
    case "/ping": await cmdPing(token, msg); return true;

    case "/iam_teacher": await cmdIamTeacher(env, token, msg, state); return true;
    case "/link_general": await cmdLink(token, msg, state, args, "link_general"); await saveState(env,state); return true;
    case "/link_parents": await cmdLink(token, msg, state, args, "link_parents"); await saveState(env,state); return true;

    case "/pickup_set": {
      const parts = args.trim().split(/\s+/);
      const cls = parseClassFrom(parts[0]||"");
      ensureClass(state, cls);
      const restS = args.trim().slice(args.indexOf(parts[0])+parts[0].length).trim();
      let mapping=null;
      if (restS.startsWith("{")){
        try{
          const obj=JSON.parse(restS); const m={};
          for(const[k,v]of Object.entries(obj||{})){
            const kk=(dayShortFromInput(k)||k.toString().toUpperCase().slice(0,2));
            if (DAYS.includes(kk)&&/^\d{1,2}:\d{2}$/.test(String(v))) m[kk]=String(v);
          }
          mapping=Object.keys(m).length?m:null;
        }catch{}
      } else {
        const out={}; const parts2=restS.split(/[;,]/).map(s=>s.trim()).filter(Boolean);
        for(const p of parts2){
          const [kr,vr]=p.split("=").map(s=>s.trim()); if(!kr||!vr) continue;
          const k=dayShortFromInput(kr)||kr.toUpperCase().slice(0,2);
          if(!DAYS.includes(k)) continue;
          if(!/^\d{1,2}:\d{2}$/.test(vr)) continue;
          out[k]=vr;
        }
        mapping=Object.keys(out).length?out:null;
      }
      if(!mapping){ await sendToSameThread("sendMessage", token, msg, { text:"–§–æ—Ä–º–∞—Ç: /pickup_set 1–ë –ü–ù=13:30,–í–¢=12:40,..." }); return true; }
      state.classes[cls].pickup_times = mapping; await saveState(env,state);
      await sendToSameThread("sendMessage", token, msg, { text:`–ì–æ—Ç–æ–≤–æ. ${cls}: ${Object.entries(mapping).map(([k,v])=>`${k}=${v}`).join(", ")}` });
      const rec=state.classes[cls];
      for(const chatId of [rec.general_chat_id, rec.parents_chat_id].filter(Boolean)){
        await sendSafe("sendMessage", token, { chat_id: chatId, text:`–û–±–Ω–æ–≤–ª–µ–Ω–æ –≤—Ä–µ–º—è –∑–∞–±–æ—Ä–∞ (${cls}):\n${formatPickupWeek(mapping)}` });
      }
      return true;
    }

    case "/pickup_week": {
      const cls = pickClassFromChat(state, msg.chat.id) || parseClassFrom(args||"");
      const rec = state.classes[cls]||{};
      if(!rec.pickup_times){ await sendToSameThread("sendMessage", token, msg, { text:"–ù—É–∂–Ω–æ —Å–Ω–∞—á–∞–ª–∞ –∑–∞–¥–∞—Ç—å —á–µ—Ä–µ–∑ /pickup_set" }); }
      else { await sendToSameThread("sendMessage", token, msg, { text:`–í—Ä–µ–º—è –∑–∞–±–æ—Ä–∞ –Ω–∞ –Ω–µ–¥–µ–ª—é ‚Äî ${cls}:\n${formatPickupWeek(rec.pickup_times)}` }); }
      return true;
    }

    case "/teach": {
      const isT = state.teacher_id && state.teacher_id===msg.from.id;
      if(!isT){ await sendToSameThread("sendMessage", token, msg, { text:"–¢–æ–ª—å–∫–æ —É—á–∏—Ç–µ–ª—å –º–æ–∂–µ—Ç –æ–±—É—á–∞—Ç—å –æ—Ç–≤–µ—Ç—ã." }); return true; }
      const m = args.match(/"([^"]+)"\s*=>\s*"([^"]+)"/);
      if(!m){ await sendToSameThread("sendMessage", token, msg, { text:'–§–æ—Ä–º–∞—Ç: /teach "—à–∞–±–ª–æ–Ω" => "–æ—Ç–≤–µ—Ç"' }); return true; }
      const [_,pat,ans] = m; state.teach=state.teach||[]; state.teach.push({pat:pat.trim(), ans:ans.trim()});
      await saveState(env,state); await sendToSameThread("sendMessage", token, msg, { text:`–î–æ–±–∞–≤–ª–µ–Ω–æ –ø—Ä–∞–≤–∏–ª–æ #${state.teach.length} ‚úÖ` }); return true;
    }
    case "/teach_list": {
      const list=state.teach||[]; if(!list.length){ await sendToSameThread("sendMessage", token, msg, { text:"–ü—Ä–∞–≤–∏–ª–∞ –ø—É—Å—Ç—ã." }); return true; }
      const out=list.map((r,i)=>`${i+1}. "${r.pat}" => "${r.ans.slice(0,80)}"`).join("\n");
      await sendToSameThread("sendMessage", token, msg, { text: out.slice(0,4000) }); return true;
    }
    case "/teach_del": {
      const isT = state.teacher_id && state.teacher_id===msg.from.id;
      if(!isT){ await sendToSameThread("sendMessage", token, msg, { text:"–î–æ—Å—Ç—É–ø —Ç–æ–ª—å–∫–æ —É—á–∏—Ç–µ–ª—é." }); return true; }
      const idx=parseInt(args,10); const list=state.teach||[];
      if(isNaN(idx)||idx<1||idx>list.length){ await sendToSameThread("sendMessage", token, msg, { text:"–£–∫–∞–∂–∏—Ç–µ –Ω–æ–º–µ—Ä –ø—Ä–∞–≤–∏–ª–∞: /teach_del 2" }); return true; }
      list.splice(idx-1,1); state.teach=list; await saveState(env,state);
      await sendToSameThread("sendMessage", token, msg, { text:"–£–¥–∞–ª–µ–Ω–æ ‚úÖ" }); return true;
    }
    case "/teach_clear": {
      const isT = state.teacher_id && state.teacher_id===msg.from.id;
      if(!isT){ await sendToSameThread("sendMessage", token, msg, { text:"–î–æ—Å—Ç—É–ø —Ç–æ–ª—å–∫–æ —É—á–∏—Ç–µ–ª—é." }); return true; }
      state.teach=[]; await saveState(env,state); await sendToSameThread("sendMessage", token, msg, { text:"–í—Å–µ –ø—Ä–∞–≤–∏–ª–∞ –æ—á–∏—â–µ–Ω—ã ‚úÖ" }); return true;
    }
    case "/persona_set": {
      const isT = state.teacher_id && state.teacher_id === msg.from.id;
      if (!isT) {
        await sendToSameThread("sendMessage", token, msg, { text: "–î–æ—Å—Ç—É–ø —Ç–æ–ª—å–∫–æ —É—á–∏—Ç–µ–ª—é." });
        return true;
      }
      const name = args.trim();
      if (!name) {
        await sendToSameThread("sendMessage", token, msg, { text: "/persona_set –ò—Ä–∏–Ω–∞ –í–ª–∞–¥–∏–º–∏—Ä–æ–≤–Ω–∞" });
        return true;
      }
      state.teacher_display_name = name;
      await saveState(env, state);
      await sendToSameThread("sendMessage", token, msg, { text: `–¢–µ–ø–µ—Ä—å –æ—Ç–≤–µ—á–∞—é –∫–∞–∫: ${name}` });
      return true;
    }
    case "/forward_unknown": {
      const isT = state.teacher_id && state.teacher_id === msg.from.id;
      if (!isT) {
        await sendToSameThread("sendMessage", token, msg, { text: "–î–æ—Å—Ç—É–ø —Ç–æ–ª—å–∫–æ —É—á–∏—Ç–µ–ª—é." });
        return true;
      }
      const v = (args || "").trim().toLowerCase();
      if (!["on", "off"].includes(v)) {
        await sendToSameThread("sendMessage", token, msg, { text: "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: /forward_unknown on|off" });
        return true;
      }
      state.forward_unknown_to_teacher = (v === "on");
      await saveState(env, state);
      await sendToSameThread("sendMessage", token, msg, { text: `–ü–µ—Ä–µ—Å—ã–ª–∞—Ç—å –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–µ –≤–æ–ø—Ä–æ—Å—ã —É—á–∏—Ç–µ–ª—é: ${state.forward_unknown_to_teacher ? "–î–ê" : "–ù–ï–¢"}` });
      return true;
    }

    // –º–µ–¥–∏–∞—Ç–µ–∫–∏
    case "/media_list": {
      const cls = parseClassFrom(args || "");
      const map = listMedia(state, cls);
      const lines = Object.keys(map).length ? Object.entries(map).map(([k, c]) => `‚àô ${k}: ${c}`).join("\n") : "—Ç–µ–º –Ω–µ—Ç";
      await sendToSameThread("sendMessage", token, msg, { text: `–ú–µ–¥–∏–∞-—Ç–µ–º—ã (${cls}):\n${lines}` });
      return true;
    }
    case "/media_del": {
      const isT = state.teacher_id && state.teacher_id === msg.from.id;
      if (!isT) {
        await sendToSameThread("sendMessage", token, msg, { text: "–î–æ—Å—Ç—É–ø —Ç–æ–ª—å–∫–æ —É—á–∏—Ç–µ–ª—é." });
        return true;
      }
      const m = args.split(/\s+/);
      const topic = (m[0] || "").trim();
      const which = (m[1] || "").trim();
      const cls = parseClassFrom(m.slice(2).join(" ") || "");
      if (!topic || !which) {
        await sendToSameThread("sendMessage", token, msg, { text: "–§–æ—Ä–º–∞—Ç: /media_del <—Ç–µ–º–∞> <‚Ññ|all> [–ö–õ–ê–°–°]" });
        return true;
      }
      const ok = delMedia(state, cls, topic, which.toLowerCase());
      await saveState(env, state);
      await sendToSameThread("sendMessage", token, msg, { text: ok ? "–£–¥–∞–ª–µ–Ω–æ ‚úÖ" : "–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ." });
      return true;
    }
    case "/media_clear": {
      const isT = state.teacher_id && state.teacher_id === msg.from.id;
      if (!isT) {
        await sendToSameThread("sendMessage", token, msg, { text: "–î–æ—Å—Ç—É–ø —Ç–æ–ª—å–∫–æ —É—á–∏—Ç–µ–ª—é." });
        return true;
      }
      const cls = parseClassFrom(args || "");
      clearMedia(state, cls);
      await saveState(env, state);
      await sendToSameThread("sendMessage", token, msg, { text: `–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ –º–µ–¥–∏–∞-–∫–æ–ª–ª–µ–∫—Ü–∏–∏ –æ—á–∏—â–µ–Ω—ã (${cls}) ‚úÖ` });
      return true;
    }

    default: return false;
  }
}

/* ---------- entry ---------- */
export default {
  async fetch(request, env) {
    const url = new URL(request.url);
    const token = env.BOT_TOKEN;

    if (url.pathname === "/") return OK("ok");

    // init webhook
    if (url.pathname === "/init" && (request.method === "GET" || request.method === "POST")) {
      if (!token || !env.PUBLIC_URL) return NO(400, "Need BOT_TOKEN and PUBLIC_URL");
      const res = await tg("setWebhook", token, {
        url: `${env.PUBLIC_URL}/webhook/${token}`,
        allowed_updates: ["message", "edited_message", "callback_query", "channel_post", "my_chat_member", "chat_member"],
        max_connections: 40,
        drop_pending_updates: false
      });
      return new Response(JSON.stringify(res), { status: 200, headers: { "content-type": "application/json" } });
    }

    if (url.pathname === `/webhook/${token}` && request.method === "POST") {
      let update;
      try { update = await request.json(); } catch { return NO(400, "bad json"); }
      const state = await loadState(env);

      // –¢–µ–∫—Å—Ç–æ–≤—ã–µ –∫–æ–º–∞–Ω–¥—ã / –Ω–∞—Ç—É—Ä–∞–ª—å–Ω—ã–µ —Ñ—Ä–∞–∑—ã
      if (update.message?.text) {
        const handled = await handleCommand(env, token, update.message, state);
        if (handled) return OK();
        const human = await handleNaturalMessage(env, token, update.message, state);
        if (human) return OK();
        // –º–æ–ª—á–∏–º
        return OK();
      }

      // –ú–µ–¥–∏–∞ –æ—Ç —É—á–∏—Ç–µ–ª—è (–õ–°)
      if (update.message && (update.message.photo?.length || update.message.video || update.message.document || update.message.audio || update.message.voice)) {
        await handleMediaFromTeacher(env, token, update.message, state);
        return OK();
      }

      return OK();
    }

    return NO();
  }
};

  
